# Sweeft
Java II Step

1. მოცემულია სტრინგი, რომელიც შეიცავს არითმეტიკულ ოპერაციებს (+,-). დაწერეთ ფუნცქია,
რომელიც გამოთვლის მოცემული არითმეტიკული ოპერაციის შედეგს int evaluateExpression(String
expression);
მაგ. expression = “5+20-8+5”. result = 22.

2. სტრინგი არის ‘ბედნიერი’ თუ მისი შემადგენელი ყოველი სიმბოლოს მომდევნო ელემენტი არ
უდრის ამ სიმბოლოს. სტრინგები შედგება მარტო ‘a’, ‘b’, ‘c’ სიმბოლოებისგან. თქვენ შემოგდით
სტრინგების ლისტი, გამოთვალეთ რამდენი სტრინგი არის ‘ბედნიერი’. int
numberOfHappyStrings(List<String> strings);
მაგ. strings = [“abbcc”, “abc”, “abcabc”, “cabcbb”], result = 2.

3. მოცემულია ერთმიმართულებიანი linked list-ის თავი. დაწერეთ ფუნქცია, რომელიც
დააბრუნებს შეტრიალებულ ვერსიას. ListNode reverseList(ListNode head);
მაგ. head = 1->2->3->4->5, result = 1<-2<-3<-4<-5.

4. მოცემულია მთელი რიცხვების ორი მასივი. nums1 და nums2. იპოვეთ ამ მასივების საერთო
ელემენტთა სიმრავლე, რომელიც შეიცავს უნიკალურ მთელ რიცხვებს. int[] findIntersection(int[]
nums1, int[] nums2);
მაგ. nums1 = [1,2,3,3,4,5], nums2 = [3,4,4,5,6,7], result = [3,4,5].

5. მოცემულია მთელ რიცხვა მასივი. იპოვეთ ელემენტების მაქსიმალური რაოდენობა, რომელთა
ჯამით მიიღება რიცხვი k. int lenOfLongSubarr(int[] array, int k); მაგ. array=[6,2,2,3,4,1], k = 8, result= 4.

6. მოცემული გვაქვს მთელი რიცხვების ორი მასივი, array და sequence. იპოვეთ თუ მეორე მასივი
პირველი მასივის ქვესიმრავლეა და ელემენტები იგივე მიმდევრობით არის მოცემული. boolean
isValidSequence(int[] array, int[] sequence);
მაგ. array = [5,1,22,25,6,-1,8,10], sequence = [1,6-1,10], result = true.
